# 卷积神经网络

## 卷积神经网络基础

### 卷积(convolutions)计算方法
有两个矩阵A(n, n), F(f, f)
f < n
在A中, 取出最左上角一个(f, f)矩阵, 和F的各个元素对应相乘, 再求和, 得到c, 
c即A和F卷积得到结果矩阵的左上角元素
再依次移动F在A中的位置, 得到结果矩阵的所有元素

### 边缘检测
考虑一个灰度图像矩阵， 为(n, n)
过滤矩阵（filter）为(f, f)
两者做卷积后, 得到一个(n - f + 1, n - f + 1)矩阵
`(n, n) * (f, f) = (n - f + 1, n - f + 1)`
此矩阵即包含了边界信息

### Padding
直接做卷积的缺点:
做卷积后, 图像都会缩小 n -> (n - f + 1)
图像边缘的大部分信息都丢失了

解决方案:
在原图周围填充一圈像素

可以使用全零来进行填充

有两种卷积:
1, Valid卷积: 不做Padding
2, Same卷积: 要求填充图像, 使得输出图像和输入图像大小一致
Same卷积Padding数量记为p, 则`p = (f - 1) / 2`

在计算机视觉中, 很少会使f为偶数

### 卷积步长
在移动F时的步长, 过去是一次移动1, 现在一次移动一个步长
如果定义padding为p
步长strides为s
卷积计算定义为*
则计算出的矩阵维度可用如下公式表示
`(n, n) * (f, f) = ((n + 2p -f) / s + 1), (n + 2p -f) / s + 1))`

### 多通道的卷积计算
当有多个通道时，例如一个RGB的图像进行卷积运算， 如下图所示：
![](_v_images/20190904232604930_21257.png =584x)

一个6*6， 3通道（RGB）的图片， 和一个3*3 3通道（RGB各对应）的filter做卷积运算
得到一个4*4的矩阵
运算方法为： 将3 * 3 * 3的filter放到如图位置上， 3 * 3 * 3 = 27个数相乘， 再求和， 得到的为4*4矩阵的左上角的数字， 依次类推

### 需要检测多个边缘时
如果要对一个图片，即检测水平边缘， 又检测垂直边缘， 则可以使用如下方法：
![Multiple filters](_v_images/20190904233655993_27586.png =640x)

6*6*3的是待检测图片， 浅黄色为垂直过滤矩阵， 深黄色为水平过滤矩阵， 分别和待检测图片做卷积，各得到一个4*4的结果矩阵，再将其合并为一个4*4*2的矩阵即可。

## 池化层
### Max pooling
常用
### Average pooling
不太常用

### 池化层的超参数
池化层没有需要学习的参数, 只是对前一层做一些固定的操作
超参数通常有:
f: filter size
s: stride

通常使用f = 2, s = 2, 使得图片缩小为原来的四分之一
偶尔也会使用f = 3, s = 2





