# numpy基础

## 矩阵操作
### 生成指定的矩阵
```
import numpy as np
A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(A)
```
输出为:
```
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```

### 随机生成矩阵
不推荐的用法
```
import numpy as np
a = np.random.randn(5)
```
此时生成的a不是一个矩阵, 建议使用如下方法
```
a = np.random.randn(5, 1)
print(a)
```
输出为  
```
[[ 1.19173693]
 [ 0.75105576]
 [ 0.74902246]
 [ 0.76313652]
 [-0.79543073]]
```

### 生成全0矩阵
```
a = np.zeros((5, 4))
print(a)
```
输出为
```
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]
```

### 矩阵转置
```
a = np.random.randn(5,1)
at = a.T
```

### 矩阵乘法
```
a = np.random.randn(5, 1)
b = np.dot(a, a.T)
print(b)
```
输出为
```
[[ 1.4202369   0.89506089  0.89263772  0.90945797 -0.94794418]
 [ 0.89506089  0.56408476  0.56255763  0.57315808 -0.59741283]
 [ 0.89263772  0.56255763  0.56103465  0.57160639 -0.59579548]
 [ 0.90945797  0.57315808  0.57160639  0.58237735 -0.60702224]
 [-0.94794418 -0.59741283 -0.59579548 -0.60702224  0.63271005]]
```
### 矩阵各个元素相乘
```
a * b # 会出发broadcast机制, 维度不够的矩阵会自动拓展
```

### 输出矩阵的维度
```
a = np.random.randn(5,4)
a.shape()
```
输出为
```
(5, 4)
```
确保一个矩阵的维度正确
```
assert(a.shape == (5, 4))
```

### 对矩阵reshape
```
a = np.random.randn(5)
a.shape
b = a.reshape(5,1)
b.shape
```
输出为:
```
(5,)
(5, 1)
```

### 对矩阵每一列(行)求和
```
B = A.sum(axis = 0) # 0表示对每一列求和, 1表示对每一行求和
B.shape
print(B)
```
输出为  
```
(3, )
[12 15 18]
```
备注, B不是一个矩阵, 要使用需要reshape成合适的矩阵

### 求矩阵每一列(行)的最大值
```
A = np.array([[-1, 2, -3, 4, 5], [0, 0, 0, 0, 0]])
print(A)
max = np.max(A, axis = 0).reshape(1, 5)    # axis = 0表示对列求最大值, 1表示对行求最大值
print(max)
```
输出为:
```
[[-1  2 -3  4  5]
 [ 0  0  0  0  0]]
[[0 2 0 4 5]]
```

### 矩阵的拓展
列拓展函数为`column_stack`
行拓展函数为`row_stack`
例子:
```
A = np.array([-1, 2, -3, 4, 5]).reshape(5, 1)
 Zero = np.zeros((5,1))
B = np.column_stack((A, Zero))
print(B)
```
输出为
```
[[-1.  0.]
 [ 2.  0.]
 [-3.  0.]
 [ 4.  0.]
 [ 5.  0.]]
```